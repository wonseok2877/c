/*
입력
입력은 총 28줄로 각 제출자(학생)의 출석번호 n(1 ≤ n ≤ 30)가 한 줄에 하나씩
주어진다. 출석번호에 중복은 없다.

출력
출력은 2줄이다. 1번째 줄엔 제출하지 않은 학생의 출석번호 중 가장 작은 것을
출력하고, 2번째 줄에선 그 다음 출석번호를 출력한다.

문제접근
1번째 생각 : 1~30까지 있는 원본 배열에서 input이 들어올 때마다 해당 값을 index를
통해 찾아서 뺄까? 마지막엔 배열에 2개의 숫자만 남도록. 출력하기 편하게. 문제점..
배열 성질에 따라서 사실상 '뺀다'는 개념을 구현할 수 없다는거. 빼고 하나씩 순서를
정렬하면 다음 input을 찾기 어려워진다.

2번째 생각 : 1~30까지의 합에서 input이 들어올 때마다 뺄까?
문제점.. 값이 남는다고 해도 두 숫자가 뭔지 알 수가 없다. 가능한 조합이 너무
많음.

3번째 생각 : 빈 배열에, input값과 동일한 index에다 값을 넣을까?
기존의 원소들은 0, 들어온건 1로 구분해서 boolean스럽게 표현
그리고 후에 0값을 갖는 두 원소만 가지고 출력.

data : input을 넣을 길이 30짜리 배열(0번째부터 시작)
logic : 1. 변수 선언
        2. 반복문 scanf. 배열의 해당 index의 값을 1로 할당
        3. 반복문. 0인 값을 찾아서, 출력. (순서가 곧 작은 순. 문제 조건 충족)
*/

#include <stdio.h>
#define LENGTH 30

int main() {
  int input, array[LENGTH] = {0}; // count?

  for (int i = 0; i < LENGTH - 2; i++) {
    scanf("%d", &input);
    array[input - 1] = input;
  }

  for (int i = 0; i < LENGTH; i++) {
    if (array[i] == 0) 
        printf("%i\n", i+1);
  }

}
